{"version":3,"sources":["App.js","serviceWorker.js","index.js"],"names":["App","props","mouseDown","initializeStartAndFinish","auxGrid","state","grid","setState","createGridRow","size","rowNumber","row","column","push","createGridColumns","rows","drawGridColumns","map","index","className","key","drawGridRows","cell","onMouseOver","handleGridUpdate","onClick","updateByClick","newGrid","resetGrid","heuristic","start","goal","Math","abs","tieBreaker","pow","containsCell","list","find","item","expand","result","northCell","eastCell","southCell","westCell","isGoal","isStart","aStar","startDistance","openList","cost","parents","score","tie","exploredList","best","sort","a","b","colorPath","setTimeout","filter","forEach","neighbour","concat","length","optimalPath","document","title","onmousedown","onmouseup","this","React","Component","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message"],"mappings":"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","file":"static/js/main.352219dc.chunk.js","sourcesContent":["import React from 'react';\nimport './App.css';\n\nclass App extends React.Component {\n  constructor(props) {\n    super(props)\n    this.optimalPath = [];\n    this.state = {\n      grid: this.createGridColumns(24),\n\n    }\n    this.initializeStartAndFinish()\n  }\n\n  mouseDown = false;\n  componentDidMount() {\n   document.title = \"Glory A*\"\n    document.onmousedown = () => {\n      this.mouseDown = true;\n    }\n    document.onmouseup = () => {\n      this.mouseDown = false;\n    }\n  }\n\n  initializeStartAndFinish = () => {\n    let auxGrid = this.state.grid\n    auxGrid[1][1].state = \"cell-begin\"\n    auxGrid[22][22].state = \"cell-end\"\n    this.setState({ grid: auxGrid })\n  }\n\n  createGridRow = (size, rowNumber) => {\n    let row = []\n    for (let column = 0; column < size; column++) {\n      row.push({ state: \"free-cell\", column: column, row: rowNumber })\n    }\n    return row;\n\n  }\n\n  createGridColumns = (size) => {\n    let grid = []\n    for (let rows = 0; rows < size; rows++) {\n      let row = this.createGridRow(size, rows)\n      grid.push(row)\n    }\n    return grid\n  }\n\n  drawGridColumns = () => {\n    return this.state.grid.map((row, index) => {\n      return (<div className=\"row-container\" key={\"row-\" + index}>\n        {this.drawGridRows(row, index)}\n      </div>)\n    })\n  }\n\n  drawGridRows = (rows, rowNumber) => {\n    return rows.map((cell, index) => {\n\n      return (\n        <button\n          className={this.state.grid[rowNumber][index].state}\n          onMouseOver={() => this.handleGridUpdate(rowNumber, index)}\n          onClick={() => this.updateByClick(rowNumber, index)}\n          key={\"cell-\" + index} />\n      )\n    })\n  }\n\n\n  handleGridUpdate = (row, column) => {\n    if (this.mouseDown) {\n      let newGrid = this.state.grid;\n      if (newGrid[row][column].state === \"free-cell\") {\n        newGrid[row][column].state = \"cell-blocked\"\n      }\n      else if (newGrid[row][column].state === \"cell-blocked\") {\n        newGrid[row][column].state = \"free-cell\"\n      }\n\n      this.setState({ grid: newGrid })\n    }\n\n\n  }\n\n  updateByClick = (row, column) => {\n\n    let newGrid = this.state.grid;\n    if (newGrid[row][column].state === \"free-cell\") {\n      newGrid[row][column].state = \"cell-blocked\"\n    }\n    else if (newGrid[row][column].state === \"cell-blocked\") {\n      newGrid[row][column].state = \"free-cell\"\n    }\n\n    this.setState({ grid: newGrid })\n\n\n\n  }\n\n  resetGrid = () => {\n    let auxGrid = this.createGridColumns(24)\n    auxGrid[1][1].state = \"cell-begin\"\n    auxGrid[22][22].state = \"cell-end\"\n    this.setState({ grid: auxGrid })\n\n  }\n\n  heuristic = (start, goal) => {\n    const result = Math.abs(start.row - goal.row) + Math.abs(start.column - goal.column);\n    return result;\n  }\n\n  tieBreaker = (start, goal) => {\n    return Math.pow((start.row - goal.row), 2) + Math.pow((start.column - goal.column), 2);\n  }\n\n  containsCell = (list, cell) => {\n    const found = list.find((item) => {\n      return (item.row === cell.row && item.column === cell.column)\n\n    });\n    if (found) {\n      return true;\n    }\n    else {\n      return false;\n    }\n  }\n\n  expand = (cell, size) => {\n    let result = [];\n\n    if (cell.row - 1 >= 0) {\n      const northCell = this.state.grid[cell.row - 1][cell.column];\n      if (northCell.state !== \"cell-blocked\") {\n        result.push(northCell);\n      }\n    }\n    if (cell.column + 1 < size) {\n      const eastCell = this.state.grid[cell.row][cell.column + 1];\n      if (eastCell.state !== \"cell-blocked\") {\n        result.push(eastCell);\n      }\n    }\n    if (cell.row + 1 < size) {\n      const southCell = this.state.grid[cell.row + 1][cell.column];\n      if (southCell.state !== \"cell-blocked\") {\n        result.push(southCell);\n      }\n    }\n\n    if (cell.column - 1 >= 0) {\n      const westCell = this.state.grid[cell.row][cell.column - 1];\n      if (westCell.state !== \"cell-blocked\") {\n        result.push(westCell);\n      }\n    }\n    return result;\n  }\n\n  // TODO: implement an animation to draw correct path\n  colorPath(parents) {\n    parents.forEach((item) => {\n      if (!this.isStart(item)) {\n        //item.state;\n        setTimeout(() => {\n          let auxGrid = this.state.grid\n          auxGrid[item.row][item.column] = item\n          auxGrid[item.row][item.column].state = \"cell-final-path\"\n          this.setState({ grid: auxGrid })\n        }, 5)\n\n\n      }\n    });\n  }\n\n  isGoal = (cell) => {\n    if (cell.state === \"cell-end\") {\n      return true;\n    }\n    else {\n      return false;\n    }\n  }\n\n  isStart = (cell) => {\n    if (cell.state === \"cell-begin\") {\n      return true;\n    }\n    else {\n      return false;\n    }\n  }\n\n  aStar = (start, goal, size) => {\n    const startDistance = this.heuristic(start, goal);\n\n    // List of unexplored cells\n    let openList = [];\n    start.cost = 0;\n    start.parents = [];\n    start.score = (0 + startDistance);\n    start.tie = this.tieBreaker(start, goal)\n    openList.push(start);\n\n    // List of explored cells\n    let exploredList = [];\n\n    while (openList.length > 0) {\n      // Sort nodes by score to find best path\n      const sortList = openList.sort((a, b) => {\n        if (a.score - b.score < 0) {\n          return -1;\n        }\n        else if (a.score - b.score > 0) {\n          return 1;\n        }\n        else {\n          if (a.tie - b.tie < 0) {\n            return -1;\n          }\n          else if (a.tie - b.tie > 0) {\n            return 1;\n          }\n          else {\n            return 0;\n          }\n        }\n      });\n\n      // The best cell is the one with the lowest score\n      const best = sortList[0];\n\n      // If the best cell is the goal, solution has been found\n      if (this.isGoal(best)) {\n        this.colorPath(best.parents);\n        break;\n      }\n\n      else {\n        // add best cell to the explored cell list\n        if (!this.isStart(best) && best.state !== \"cell-blocked\") {\n          setTimeout(() => {\n            let auxGrid = this.state.grid\n\n            auxGrid[best.row][best.column] = best\n            auxGrid[best.row][best.column].state = \"cell-test\"\n            this.setState({ grid: auxGrid })\n          }, 4)\n        }\n\n        exploredList.push(best);\n\n        // remove best from the open list\n        openList = openList.filter((item) => { return !(item.row === best.row && item.column === best.column) });\n\n        // expand the best node\n        const permissibleNeighbours = this.expand(best, size);\n\n        // eslint-disable-next-line no-loop-func\n        permissibleNeighbours.forEach((neighbour) => {\n\n          // but only if they are not in one of the lists of open or explored nodes\n          if (!this.containsCell(openList, neighbour) && !this.containsCell(exploredList, neighbour)) {\n            neighbour.cost = (best.cost + 1);\n            neighbour.parents = best.parents.concat([best]);\n            neighbour.score = (best.cost + 1 + this.heuristic(neighbour, goal));\n            neighbour.tie = this.tieBreaker(neighbour, goal);\n            openList.push(neighbour);\n          }\n          else {\n            const score = (best.cost + 1 + this.heuristic(neighbour, goal));\n            if (score < neighbour.score) {\n              neighbour.parents = best.parents.concat([best]);\n              neighbour.score = (best.cost + 1 + this.heuristic(neighbour, goal));\n              neighbour.tie = this.tieBreaker(neighbour, goal);\n            }\n          }\n        });\n      }\n    }\n\n  }\n  render() {\n    return (\n      <div className=\"main-page\">\n        <div className=\"left-screen-container\">\n\n          {this.drawGridColumns()}\n\n        </div>\n        <div className=\"right-screen-container\">\n          <h1>Glory A*</h1>\n          <p>This is a visual representation of the A* algorithm, developed in 1968 by Peter Hart, Nils Nilsson and Bertram Raphael of the Stanford Research Intitute.</p>\n          <p>The A* is considered to be the most important pathfinder algorithm, and is widely used in many applications. This implementation was made by Deliton Junior in 2020. </p>\n          <button className=\"push_button blue\" onClick={() => this.aStar(this.state.grid[1][1], this.state.grid[22][22], 24)}>Run simulation</button>\n          <button className=\"push_button red\" onClick={this.resetGrid}>Reset grid</button>\n        </div>\n\n      </div>\n    );\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}